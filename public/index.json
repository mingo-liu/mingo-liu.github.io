[{"content":"Go basics 导入本地包 1. 创建模块 初始化模块：\n在本地创建模块目录并初始化： 1 2 3 mkdir mymodule cd mymodule go mod init mymodule 创建代码文件：\n创建一个 hello.go 文件，编写模块的功能： 1 2 3 4 5 6 7 package mymodule import \u0026#34;fmt\u0026#34; func SayHello(name string) { fmt.Printf(\u0026#34;Hello, %s!\\n\u0026#34;, name) } 生成可导入的本地模块：\n确保模块代码能够正常工作，mymodule 是模块路径。 2.在另一个项目中导入本地模块 1.创建新项目：\n新建一个项目目录： 1 2 3 mkdir myproject cd myproject go mod init myproject 编辑模块依赖：\n在 myproject 中指向本地模块的路径： 1 go mod edit -replace=mymodule=../mymodule 此时go.mod文件中会添加\n1 replace mymodule =\u0026gt; ../mymodule 创建调用代码：\n在项目中调用模块： 1 2 3 4 5 6 7 package main import \u0026#34;mymodule\u0026#34; func main() { mymodule.SayHello(\u0026#34;World\u0026#34;) } 同步依赖：\n使用 go mod tidy 同步依赖，验证模块可以正常引用： 1 go mod tidy 1 2 3 4 replace mymodule =\u0026gt; ../mymodule\t// 执行go mod tidy添加 require mymodule v0.0.0-00010101000000-000000000000 上述两行代码页可以手动添加到 go.mod 文件中\n运行项目：\n在项目目录下运行代码： 1 go run main.go 本地目录结构：\n1 2 3 4 5 6 7 /path/to/projects/ ├── mymodule/ │ ├── go.mod │ ├── hello.go ├── myproject/ ├── go.mod ├── main.go 打印控制 %q：带引号输出字符串。 值类型和引用类型 go中的基本数据类型\n1 2 3 4 5 6 7 8 9 int uint float32 float64 complex64 complex128 bool string go中的复合类型\n1 2 3 4 5 6 7 8 9 10 11 普通数组 slice map chan struct 函数 值类型：\n赋值或传递时，会进行值的拷贝，新的变量与原变量互不影响。\n每个变量都有自己独立的内存空间。\n1 int, float, string, array, struct 引用类型\n赋值或传递时，会进行地址的拷贝，多个变量指向同一块内存。\n修改一个变量的值，会影响其他指向相同地址的变量。\n1 pointer, slice, map, channel byte (字符) 和 rune 类型 uint8类型，也叫 byte 类型，代表 ASCII 的一个字符\nrune 类型，代表一个 UTF-8字符，实际是一个int32类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var a = \u0026#39;a\u0026#39; // 默认输出ASCII值 fmt.Printf(\u0026#34;a = %v, type a = %T\\n\u0026#34;, a, a)\t// a = 97, type a = int32 // 原样输出字符 fmt.Printf(\u0026#34;a = %c, type a = %T\\n\u0026#34;, a, a)\t// a = a, type a = int32 var str = \u0026#34;this\u0026#34; fmt.Printf(\u0026#34;str[1] = %c, type str[1] = %T\\n\u0026#34;, str[1]\t, str[1]) // str[1] = h, type str[1] = uint8 // 一个汉字占用3个字节（UTF-8编码），一个字母占用1个字节（ASCII） fmt.Println(len(str))\t// 4个字节 var str2 = \u0026#34;你好go\u0026#34; fmt.Println(len(str2))\t// 8个字节 // 遍历字符串 for i := 0; i \u0026lt; len(str); i++ {\t// 字符默认使用 byte 类型 fmt.Printf(\u0026#34;%c %T | \u0026#34;, str[i], str[i]) } fmt.Println() for _, c := range str {\t// 默认使用 rune 类型 fmt.Printf(\u0026#34;%c %T | \u0026#34;, c, c) } fmt.Println() // 修改字符串 // str[0] = \u0026#39;c\u0026#39;\t// error，不能直接修改 byteStr := []byte(str) byteStr[0] = \u0026#39;T\u0026#39; fmt.Println(string(byteStr)) runeStr := []rune(str2) runeStr[0] = \u0026#39;不\u0026#39; fmt.Println(string(runeStr)) 数组和切片（slice） 值类型：赋值和传参会拷贝整个变量或数组，改变副本，不会改变本身的值。\n引用类型：\n数组的长度是编译时就确定的，不能更改。基本数据类型和数组都是值类型\n切片是一个动态数组，可以在运行时改变大小。切片是引用类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //数组 var arr = [...]int{1, 2, 3, 4}\t// 数组长度由元素数量推导得出 var arr1 = [5]int{1, 2, 3, 4, 5} var arr = [3][2] string { {\u0026#34;zjnu\u0026#34;, \u0026#34;qlu\u0026#34;}, {\u0026#34;xxx\u0026#34;, \u0026#34;bxx\u0026#34;}, {\u0026#34;sdf\u0026#34;, \u0026#34;hello\u0026#34;}, }\tfmt.Println(arr[0], arr[0][0]) // 遍历二维数组 for i := 0; i \u0026lt; len(arr); i++ { for j := 0; j \u0026lt; len(arr[i]); j++ { fmt.Printf(\u0026#34;%v \u0026#34;, arr[i][j]) } fmt.Println() } for _, val1 := range arr { for _, val2 := range val1 { fmt.Printf(\u0026#34;%v \u0026#34;, val2) } fmt.Println() } 1 2 3 4 5 6 7 8 9 10 11 // 切片 var arr = []int{1, 2, 3, 4} arr2 := make([]int, 5) //创建一个空的mxn的切片 slice := make([][]int, m) // 创建一个有 m 行的切片 // 为每一行分配 n 个元素 for i := 0; i \u0026lt; m; i++ { slice[i] = make([]int, n) // 每行分配 n 个元素 } 切片的引用行为\n切片本身是一个结构体，包含以下内容： 指向底层数组的指针。 切片的长度。 切片的容量。 当切片作为函数参数传递时，Go 会按值拷贝切片结构体。\n这意味着函数接收的是原切片结构体的副本，但该副本仍然指向相同的底层数组。 修改副本的元素会反映到原始切片，因为它们共享底层数组。 但如果修改切片的结构体本身（如重新分配底层数组或改变长度），则不会影响原始切片。 关于切片的 append 操作 Go切片append采坑经验分享\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func main() { var ans [][]string path := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} // Append by reference ans = append(ans, path) path[0] = \u0026#34;xx\u0026#34; fmt.Println(\u0026#34;ans: By reference:\u0026#34;, ans) // [[a b c]] fmt.Println(\u0026#34;path:\u0026#34;, path) // Append by copying ans = nil // Clear ans for comparison path = []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} // Reset path ans = append(ans, append([]string(nil), path...)) path = append(path, \u0026#34;c\u0026#34;) // Modify path fmt.Println(\u0026#34;By copying:\u0026#34;, ans) // [[a b]] } ans = append(ans, path)：直接将 path 引用添加到 ans 中。如果后续修改了 path 的内容，则 ans 中对应的引用指向的内容也会改变。 ans = append(ans, append([]string(nil), path...)：创建了 path 的一个副本（深拷贝），然后将这个副本添加到 ans 中。 []string(nil) 表示一个零长度、零容量的切片，它没有底层数组。 path... 是一个切片展开操作。它会将切片 path 中的元素拆开，传递给 append 函数。 切片传值操作，append未触发扩容，会同时修改底层数组的值，但不会影响原切片的长度和容量；当触发扩容，那么会产生副本，后面的修改则会和原底层数组剥离开，互不影响。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { path := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} ans := [][]string{} fmt.Printf(\u0026#34;Before append, path address: %p\\n\u0026#34;, \u0026amp;path[0]) // 打印 path 的内存地址 ans = append(ans, path) // 将 path 添加到 ans 中 fmt.Printf(\u0026#34;After append, ans address: %p\\n\u0026#34;, \u0026amp;ans[0][0]) // 打印 ans 中第一个元素的内存地址 path = append(path, \u0026#34;c\u0026#34;) // 修改 path，增加了 \u0026#34;c\u0026#34; fmt.Printf(\u0026#34;After modify, path address: %p\\n\u0026#34;, \u0026amp;path[0]) // 打印修改后的 path 的内存地址 fmt.Println(\u0026#34;ans: By reference:\u0026#34;, ans) // 打印 ans path[0] = \u0026#34;aa\u0026#34; fmt.Println(\u0026#34;path: By reference:\u0026#34;, path) // 打印 ans fmt.Println(\u0026#34;ans: By reference:\u0026#34;, ans) // 打印 ans } //output: Before append, path address: 0xc000038040 After append, ans address: 0xc000038040 After modify, path address: 0xc00007c0c0 ans: By reference: [[a b]] path: By reference: [aa b c] ans: By reference: [[a b]] 运算符 在golang中，++和--只能单独使用\n1 2 3 4 var i int = 1 var a int a = i++\t// error golang中没有前置的++和--\n1 2 3 4 var i int = 1 ++i\t//error --i\t// error 复合运算符\n1 2 3 4 5 += -= *= /= %= 位运算符\n1 2 3 4 5 \u0026amp; | ^ \u0026lt;\u0026lt; \u0026gt;\u0026gt; :=\n:= 会声明并初始化变量。\n如果左侧的变量已经在当前作用域中存在，则不会重新声明，而是直接复用这些变量。\n如果左侧有新的变量，那么会声明新的变量，同时复用已有的变量。\n1 2 3 4 5 6 // 情况1 func main() { db, err := fun1() db1, err := fun2() // 复用 err，声明 db1 fmt.Println(db, db1, err) } 1 2 3 4 5 6 7 8 9 // 情况2 func main() { db, err := fun1() { db1, err := fun2() // 这里的 err 是新的变量 fmt.Println(db1, err) } fmt.Println(db, err) // 外层的 err 不受内层影响 } 条件和循环语句 1 2 3 4 5 6 7 8 9 10 11 12 if score := 75; score \u0026gt; 90 {\t// score 的用于位于if语句中 fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt; 75 { fmt.Println(\u0026#34;B\u0026#34;)\t} else { fmt.Println(\u0026#34;C\u0026#34;) } if x := 10; y := 20; x \u0026gt; y { // 编译报错：简单语句中不能包含多条语句 fmt.Println(\u0026#34;Invalid!\u0026#34;) } 1 2 3 4 5 6 7 8 9 for i := 0; i \u0026lt; 5; ++i { fmt.Println(i) } // go中没有while循环，使用 for 替代 for i != 10 { fmt.Println(i) ++i } 类型别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 type counter int package main import \u0026#34;fmt\u0026#34; // 定义一个基于 int 类型的自定义类型 counter type counter int func main() { // 定义一个 int 类型的变量 var x int = 42 // 定义一个 counter 类型的变量 var y counter = 100 // 类型转换：从 counter 转换为 int fmt.Println(int(y)) // 输出: 100 // 类型转换：从 int 转换为 counter y = counter(x) fmt.Println(y) // 输出: 42 } counter 是 int 类型的一个别名，但它和 int 在类型系统中是不同的类型。你不能直接将一个 int 类型的变量赋值给一个 counter 类型的变量，除非进行显式的类型转换。\nSprintf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int %d float %f bool %t byte %c // 其它类型转换为string类型 var a int = 2 var f float32 = 3.14 var t bool = false var b byte = 1 str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, a) str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, f) str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, t) str4 := fmt.Sprintf(\u0026#34;%b\u0026#34;, b) fmt.Println(str1, str2, str3, str4)\t// 2 3.140000 false 1 // 使用 strconv 将其它类型转换为string类型 var a int = 2 var f float32 = 3.141596 var t bool = false var b byte = 1 s1 := strconv.FormatInt(int64(a), 10) s2 := strconv.FormatFloat(float64(f), \u0026#39;f\u0026#39;, 2, 64) s3 := strconv.FormatBool(t) s4 := strconv.FormatUint(\u0026#39;a\u0026#39;, 10) fmt.Println(s1, s2, s3, s4)\t// 2 3.14 false 97 struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Student struct { Name string Grade map[string]int } func main() { stu := Student{} /* stu.Grade[\u0026#34;math\u0026#34;] = 90\t// error:此时的stu.Grade是nil的，必须为其分配内存 */ stu.Grade = make(map[string]int) stu.Grade[\u0026#34;math\u0026#34;] = 100 stu.Grade[\u0026#34;chinese\u0026#34;] = 90 fmt.Printf(\u0026#34;Name = %v, grade = %v\\n\u0026#34;, stu.Name, stu.Grade) } output: Name = , grade = map[chinese:90 math:100] string 使用 + 或 Sprintf 拼接字符串 结构体值接受者和结构体指针接收者的区别 接收者的命名通常为结构体名称的简写，一般采用小写字母形式，常见的是结构体名称的第一个字母或前几个字母。\n值接收者是指通过结构体的副本来调用方法，也就是说，方法内修改的是结构体的一个副本，不会影响原始结构体。\n值接收者对应的结构体实例化后的结构体值类型或者指针类型都可以赋值给接口变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; type Ipoint interface { Add(Point) Point } // 定义结构体 type Point struct { X, Y int } // 使用值接收者定义方法 func (p Point) Add(other Point) Point { return Point{p.X + other.X, p.Y + other.Y} } func main() { p1 := Point{1, 2}\t// 结构体值类型 p2 := \u0026amp;Point{3, 4}\t// 结构体指针类型 var ip Ipoint = p1 result := ip.Add(*p2) fmt.Println(result) } 指针接收者是指通过结构体的指针来调用方法，即方法内的修改会直接影响原始结构体。指针接收者通常用于需要修改结构体内容的方法，或者结构体较大时为了提高性能（避免值拷贝）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; type Ipoint interface { Add(Point) Point } // 定义结构体 type Point struct { X, Y int } // 使用指针接收者定义方法 func (p *Point) Add(other Point) Point { return Point{p.X + other.X, p.Y + other.Y} } func main() { p1 := \u0026amp;Point{1, 2}\t// 结构体指针类型 p2 := Point{3, 4}\tvar ip Ipoint = p1\t// 正确，只能将结构体指针类型的对象赋值为接口 result := ip.Add(p2) fmt.Println(result) } 断言 类型断言：\n1.单值形式：如果断言失败，程序会触发 panic，导致运行时错误。 value := arg.(string)\n2.多值形式（推荐）：如果断言失败，不会 panic，而是通过 ok 值告知调用者。 value, ok := arg.(string)\n1.具体类型断言：str, ok := i.(string)\ni 是一个接口类型（如 interface{}），断言它是具体类型 string。 2.接口类型断言：w, ok := r.(io.Writer)\nr 是一个接口类型（如 interface{}），断言它实现了某个接口（这里是 io.Writer）。如果 r 的实际值是某个类型的值，并且该类型实现了 io.Writer 接口，断言成功，w 被赋值为 r 的值，ok = true。 函数 匿名函数可以直接在其作用域内使用外部变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { // 外部变量 base := 10 // 匿名函数，直接访问外部变量 increment := func() int { base++ // 修改外部变量 return base } // 调用匿名函数 fmt.Println(increment()) // 输出：11 fmt.Println(increment()) // 输出：12 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func longestCommonSubsequence(text1 string, text2 string) int { m := len(text1) n := len(text2) dp := make([][]int, m + 1) for i := range dp { dp[i] = make([]int, n + 1) for j := range dp[i] { dp[i][j] = -1\t// 初始化元素 } } var dfs func(int, int) int dfs = func(i, j int) int { if i \u0026lt; 0 || j \u0026lt; 0 { return 0 } res := \u0026amp;dp[i][j] if *res != -1 { return *res } if text1[i] == text2[j] { *res = dfs(i - 1, j - 1) + 1 } else { *res = max(dfs(i - 1, j), dfs(i, j - 1)) } return *res } return dfs(m - 1, n - 1) } select 多个 case 同时满足条件：当 select 中的多个 case 都可以立即执行时，Go 会随机选择一个执行，剩下的 case 会被跳过，直到下次执行时它们才有可能被选择。\n如果没有 case 就绪，将会执行default处的语句（如果有的话）。如果没有default，select 会阻塞等待某一个 case 就绪。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func main() { intChan := make(chan int, 5) stringChan := make(chan string, 5) for i := 0; i \u0026lt; 5; i++ { intChan \u0026lt;- i } for i := 0; i \u0026lt; 5; i++ { stringChan \u0026lt;- fmt.Sprintf(\u0026#34;str%d\u0026#34;, i) } // 前两个case 都是满足，因此会从中随机选择一个执行 for { select { case val := \u0026lt;-intChan: fmt.Println(\u0026#34;int = \u0026#34;, val) case val := \u0026lt;-stringChan: fmt.Println(\u0026#34;string = \u0026#34;, val) default: fmt.Println(\u0026#34;所有数据读取完毕...\u0026#34;)\treturn } } } make和new的区别 make 只能用于slice, map, channal，为对象分配内存，并返回该对象的引用类型本身。slice, map, channal 本身就是引用类型。\nnew可用于任意类型，为对象分配内存并返回指向该对象的指针\n用于分配任何类型的内存，但不会初始化。 返回一个指向类型的指针，类型中的值为零值（zero value） 不常用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // new var a *int a = new(int)\t// 分配内存 *a = 100 // make slice := make([]int, 0, 100) hash := make(map[int]bool) ch := make(chan int, 5) // the difference between new and make p := new(chan int) // p has type: *chan int c := make(chan int) // c has type: chan int 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { hash := make(map[string]int) hash[\u0026#34;nihao\u0026#34;] = 123 hash[\u0026#34;hello\u0026#34;] = 456 fmt.Printf(\u0026#34;%v %T\\n\u0026#34;, hash, hash) // 使用 new 分配 map 的内存，得到一个 map 的指针 hash2 := new(map[string]int) // 此时 *hash2 是 nil，需要用 make 初始化 *hash2 = make(map[string]int) (*hash2)[\u0026#34;nihao\u0026#34;] = 123 (*hash2)[\u0026#34;hello\u0026#34;] = 456 fmt.Printf(\u0026#34;%v %T\\n\u0026#34;, *hash2, hash2) } Goroutine 用户级线程与内核级线程的区别 用户级线程（ULT）：是由用户空间的线程库（如 pthread 库）管理和调度的，操作系统内核对这些线程并不知情。用户级线程的调度和管理完全由用户空间的线程库来完成，内核认为一个进程是一个线程，因此不会对这些线程的创建、销毁或调度做出任何直接的决策。 优点：切换速度快，因为没有涉及内核的上下文切换。 缺点：如果一个线程在用户空间阻塞（例如进行 I/O 操作），整个进程都会被阻塞，因为内核不知道该进程内有多个线程。 内核级线程（KLT）：是由操作系统内核管理和调度的，内核知道进程内部有多个线程，并为每个线程分配独立的调度单位和资源。内核负责在 CPU 上调度这些线程，并处理它们的上下文切换。 优点：内核能够独立调度各个线程，如果一个线程阻塞，其他线程可以继续执行。 缺点：线程切换相对较慢，因为需要进行内核级的上下文切换。 goroutine 调度器的设计策略\n复用线程 利用并行：GOMAXPROCS限定P的个数=CPU核数/2 抢占 全局G队列 for 循环中使用goroutine\n在循环中开启 goroutine，传递参数最好通过变量赋值，而不是利用函数闭包; 因为 goroutine 最终读取变量的时间是不确定的，从而 goroutine 中获取到变量的值不一定符合最初的预期。 sender blocks until the receiver receives!\nChannel 使用 channel 同步两个 goroutine\n无缓冲的channel\nc := make(chan int) 有缓冲的channel\nc := make(chan int, 3) Rpc 远程过程调用（remote procedure call）\n运行在一台计算机的程序调用另一个地址空间（通常为网络上的另一台计算机）的程序。 是一种进程间通信的模式，程序分布于不同的地址空间（同一台计算机/不同计算机）。 Rpc definition Go-即时通讯系统 ","permalink":"http://localhost:1313/posts/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","summary":"Golang基础语法介绍","title":"Go基础语法"},{"content":"vscode + vim 参考配置视频\ntmux教程\nvim模式 普通（Normal）模式 插入模式 命令模式 可视模式 Normal模式 光标移动 1 2 3 4 w 跳到下一个单词开头 b 跳到本单词或上一个单词开头 begin e 跳到本单词或下一个单词开头 end ge 跳到上一个单词结尾 1 2 3 4 5 0 跳到行首 ^ 跳到从行首开始第一个非空字符 $ 跳到行尾 gg 跳到第一行 G 跳到最后一行 1 2 3 4 5 6 7 8 f{char} 光标跳到当前行下个{char}所在位置 F{char} 光标反向跳到当前行上一个{char}所在位置 t{char} 光标跳到当前行下个{char}的前一个字符所在位置 T{char} 光标反向跳到当前行上一个{char}的后一个字符所在位置 ; 重复上一次的字符查找操作 , 反向重复上一次的查找操作 ","permalink":"http://localhost:1313/posts/vim/","summary":"本文主要介绍了vim的常见用法","title":"第二篇文章"},{"content":"介绍 This is bold text, and this is emphasized text.\nvisit the Hugo website!\n学校 学院 地址 代码 1 2 3 4 import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello world\u0026#34;) } ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"这是一个测试文件\u0026hellip;","title":"我的第一篇博客"},{"content":"关于我 我是谁？ 我从哪里来？ 我到哪里去？ ","permalink":"http://localhost:1313/about/","summary":"\u003ch3 id=\"关于我\"\u003e关于我\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e我是谁？\u003c/li\u003e\n\u003cli\u003e我从哪里来？\u003c/li\u003e\n\u003cli\u003e我到哪里去？\u003c/li\u003e\n\u003c/ul\u003e","title":""}]